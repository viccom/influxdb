// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: values_constant.gen.go.tmpl

package gen

import (
	"time"

	"github.com/influxdata/influxdb/tsdb/cursors"
)

type FloatConstantValuesSequence struct {
	vals  FloatArray
	n     int
	t     int64
	state struct {
		n int
		t int64
		d int64
		v float64
	}
}

func NewFloatConstantValuesSequence(n int, start time.Time, delta time.Duration, v float64) *FloatConstantValuesSequence {
	g := &FloatConstantValuesSequence{
		vals: *NewFloatArrayLen(cursors.DefaultMaxPointsPerBlock),
	}
	g.state.n = n
	g.state.t = start.UnixNano()
	g.state.d = int64(delta)
	g.state.v = v
	g.Reset()
	return g
}

func (g *FloatConstantValuesSequence) Reset() {
	g.n = g.state.n
	g.t = g.state.t
}

func (g *FloatConstantValuesSequence) Next() bool {
	if g.n == 0 {
		return false
	}

	c := min(g.n, cursors.DefaultMaxPointsPerBlock)
	g.n -= c
	g.vals.Timestamps = g.vals.Timestamps[:c]
	g.vals.Values = g.vals.Values[:c]

	var (
		t  = g.t
		ts = g.vals.Timestamps
		vs = g.vals.Values
		d  = g.state.d
	)
	for i := 0; i < len(ts) && i < len(vs); i++ {
		ts[i] = g.t
		vs[i] = g.state.v
		t += d
	}
	g.t = t

	return true
}

func (g *FloatConstantValuesSequence) Values() Values {
	return &g.vals
}

type IntegerConstantValuesSequence struct {
	vals  IntegerArray
	n     int
	t     int64
	state struct {
		n int
		t int64
		d int64
		v int64
	}
}

func NewIntegerConstantValuesSequence(n int, start time.Time, delta time.Duration, v int64) *IntegerConstantValuesSequence {
	g := &IntegerConstantValuesSequence{
		vals: *NewIntegerArrayLen(cursors.DefaultMaxPointsPerBlock),
	}
	g.state.n = n
	g.state.t = start.UnixNano()
	g.state.d = int64(delta)
	g.state.v = v
	g.Reset()
	return g
}

func (g *IntegerConstantValuesSequence) Reset() {
	g.n = g.state.n
	g.t = g.state.t
}

func (g *IntegerConstantValuesSequence) Next() bool {
	if g.n == 0 {
		return false
	}

	c := min(g.n, cursors.DefaultMaxPointsPerBlock)
	g.n -= c
	g.vals.Timestamps = g.vals.Timestamps[:c]
	g.vals.Values = g.vals.Values[:c]

	var (
		t  = g.t
		ts = g.vals.Timestamps
		vs = g.vals.Values
		d  = g.state.d
	)
	for i := 0; i < len(ts) && i < len(vs); i++ {
		ts[i] = g.t
		vs[i] = g.state.v
		t += d
	}
	g.t = t

	return true
}

func (g *IntegerConstantValuesSequence) Values() Values {
	return &g.vals
}

type UnsignedConstantValuesSequence struct {
	vals  UnsignedArray
	n     int
	t     int64
	state struct {
		n int
		t int64
		d int64
		v uint64
	}
}

func NewUnsignedConstantValuesSequence(n int, start time.Time, delta time.Duration, v uint64) *UnsignedConstantValuesSequence {
	g := &UnsignedConstantValuesSequence{
		vals: *NewUnsignedArrayLen(cursors.DefaultMaxPointsPerBlock),
	}
	g.state.n = n
	g.state.t = start.UnixNano()
	g.state.d = int64(delta)
	g.state.v = v
	g.Reset()
	return g
}

func (g *UnsignedConstantValuesSequence) Reset() {
	g.n = g.state.n
	g.t = g.state.t
}

func (g *UnsignedConstantValuesSequence) Next() bool {
	if g.n == 0 {
		return false
	}

	c := min(g.n, cursors.DefaultMaxPointsPerBlock)
	g.n -= c
	g.vals.Timestamps = g.vals.Timestamps[:c]
	g.vals.Values = g.vals.Values[:c]

	var (
		t  = g.t
		ts = g.vals.Timestamps
		vs = g.vals.Values
		d  = g.state.d
	)
	for i := 0; i < len(ts) && i < len(vs); i++ {
		ts[i] = g.t
		vs[i] = g.state.v
		t += d
	}
	g.t = t

	return true
}

func (g *UnsignedConstantValuesSequence) Values() Values {
	return &g.vals
}

type StringConstantValuesSequence struct {
	vals  StringArray
	n     int
	t     int64
	state struct {
		n int
		t int64
		d int64
		v string
	}
}

func NewStringConstantValuesSequence(n int, start time.Time, delta time.Duration, v string) *StringConstantValuesSequence {
	g := &StringConstantValuesSequence{
		vals: *NewStringArrayLen(cursors.DefaultMaxPointsPerBlock),
	}
	g.state.n = n
	g.state.t = start.UnixNano()
	g.state.d = int64(delta)
	g.state.v = v
	g.Reset()
	return g
}

func (g *StringConstantValuesSequence) Reset() {
	g.n = g.state.n
	g.t = g.state.t
}

func (g *StringConstantValuesSequence) Next() bool {
	if g.n == 0 {
		return false
	}

	c := min(g.n, cursors.DefaultMaxPointsPerBlock)
	g.n -= c
	g.vals.Timestamps = g.vals.Timestamps[:c]
	g.vals.Values = g.vals.Values[:c]

	var (
		t  = g.t
		ts = g.vals.Timestamps
		vs = g.vals.Values
		d  = g.state.d
	)
	for i := 0; i < len(ts) && i < len(vs); i++ {
		ts[i] = g.t
		vs[i] = g.state.v
		t += d
	}
	g.t = t

	return true
}

func (g *StringConstantValuesSequence) Values() Values {
	return &g.vals
}

type BooleanConstantValuesSequence struct {
	vals  BooleanArray
	n     int
	t     int64
	state struct {
		n int
		t int64
		d int64
		v bool
	}
}

func NewBooleanConstantValuesSequence(n int, start time.Time, delta time.Duration, v bool) *BooleanConstantValuesSequence {
	g := &BooleanConstantValuesSequence{
		vals: *NewBooleanArrayLen(cursors.DefaultMaxPointsPerBlock),
	}
	g.state.n = n
	g.state.t = start.UnixNano()
	g.state.d = int64(delta)
	g.state.v = v
	g.Reset()
	return g
}

func (g *BooleanConstantValuesSequence) Reset() {
	g.n = g.state.n
	g.t = g.state.t
}

func (g *BooleanConstantValuesSequence) Next() bool {
	if g.n == 0 {
		return false
	}

	c := min(g.n, cursors.DefaultMaxPointsPerBlock)
	g.n -= c
	g.vals.Timestamps = g.vals.Timestamps[:c]
	g.vals.Values = g.vals.Values[:c]

	var (
		t  = g.t
		ts = g.vals.Timestamps
		vs = g.vals.Values
		d  = g.state.d
	)
	for i := 0; i < len(ts) && i < len(vs); i++ {
		ts[i] = g.t
		vs[i] = g.state.v
		t += d
	}
	g.t = t

	return true
}

func (g *BooleanConstantValuesSequence) Values() Values {
	return &g.vals
}
